<!doctype html>
<html lang="hi">
<head>
  <link rel="icon" href="favicon-32x32.png" type="image/x-icon">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Online Image Resizer Tool | Bulk Resize, Compress & Convert Images Free – multiimagex.online</title>
<meta name="description" content="Free online image resizer tool by multiimagex.online. Resize, compress, convert, crop, rotate, and optimize unlimited images at once. Fast, secure, mobile-friendly, and 100% client-side." />
<meta name="keywords" content="image resizer,photo resizer,bulk image resizer,online image resize,resize images online,image compressor,online image converter,convert to webp,resize jpg,resize png,multiimagex.online" />
<link rel="icon" href="data:,">
<style>
  :root{
    --bg:#ffffff; --card:#f7f9fb; --muted:#6b7280; --accent:#0f62fe; --btnbg:#0f62fe;
    --btnfg:#fff; --radius:12px; --glass: rgba(15,98,254,0.06);
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  body{margin:0;background:var(--bg);color:#0b1226;line-height:1.4;padding:20px;}
  header{max-width:1100px;margin:0 auto 18px}
  .brand{display:flex;gap:12px;align-items:center}
  .logo{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#6dd3ff);display:flex;align-items:center;justify-content:center;color:white;font-weight:700}
  h1{margin:0;font-size:20px}
  p.lead{margin:6px 0 0;color:var(--muted);font-size:13px}

  .container{max-width:1100px;margin:18px auto;display:grid;grid-template-columns:380px 1fr;gap:18px}
  .card{background:var(--card);padding:16px;border-radius:var(--radius);box-shadow:0 6px 18px rgba(12,20,30,0.04)}
  .uploader{border:2px dashed #e6eefc;border-radius:10px;padding:18px;display:flex;flex-direction:column;gap:10px;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(255,255,255,0.6), transparent)}
  .uploader.dragover{border-color:var(--accent);box-shadow:0 6px 20px var(--glass)}
  .btn{background:var(--btnbg);color:var(--btnfg);border:none;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  .btn.secondary{background:#eef3ff;color:var(--accent);border:1px solid #dbe9ff}
  .small{font-size:13px;color:var(--muted)}
  input[type="range"]{width:100%}
  label{display:block;font-size:13px;margin-bottom:6px;color:#0b1226}
  .settings{display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:10px}
  .row > *{flex:1}
  .thumbs{display:grid;grid-template-columns:repeat(auto-fill, minmax(140px,1fr));gap:12px}
  .thumb{background:white;border-radius:10px;padding:8px;display:flex;flex-direction:column;gap:8px;align-items:center}
  .thumb img{max-width:120px;max-height:90px;border-radius:8px;object-fit:contain;background:#fff}
  .meta{font-size:12px;color:var(--muted);text-align:center}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .pill{background:#f2f7ff;padding:6px 8px;border-radius:999px;font-size:12px;color:var(--accent)}
  footer.info{max-width:1100px;margin:14px auto;color:var(--muted);font-size:13px}
  progress{width:100%}
  @media (max-width:900px){
    .container{grid-template-columns:1fr; padding:0 6px}
  }
</style>
<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@type":"WebPage",
  "name":"Online Image Resizer Tool – multiimagex.online",
  "description":"Resize, compress, convert, and optimize unlimited images in your browser. 100% client-side, fast and secure.",
  "publisher":{"@type":"Organization","name":"multiimagex.online"}
}
</script>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo">M</div>
      <div>
        <h1>Online Image Resizer Tool</h1>
        <p class="lead">Bulk resize, compress & convert images — 100% client-side • multiimagex.online</p>
      </div>
    </div>
  </header>

  <main class="container">
    <aside class="card">
      <div class="uploader" id="uploader">
        <div style="text-align:center">
          <strong>Drag & Drop images here</strong>
          <div class="small">or</div>
        </div>
        <input id="fileInput" type="file" accept="image/*" multiple style="display:none" />
        <button class="btn" id="selectBtn">Select Images</button>
        <div class="small">Supported: JPG, PNG, WEBP, GIF, SVG</div>
      </div>

      <hr style="margin:12px 0">

      <div class="settings">
        <label>Resize Mode</label>
        <select id="mode" class="small" style="padding:8px;border-radius:8px">
          <option value="width">By Width (px)</option>
          <option value="height">By Height (px)</option>
          <option value="percent">By Percentage (%)</option>
          <option value="custom">Custom (W x H)</option>
        </select>

        <div id="modeInputs">
          <div class="row">
            <input id="widthInp" type="number" placeholder="Width px" min="1" />
            <input id="heightInp" type="number" placeholder="Height px" min="1" />
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <label style="margin:0"><input id="keepRatio" type="checkbox" checked /> Maintain aspect ratio</label>
            <div style="flex:1"></div>
            <select id="ratioPreset" style="padding:6px;border-radius:8px;font-size:13px">
              <option value="">Preset ratio</option>
              <option value="1:1">1:1</option>
              <option value="3:2">3:2</option>
              <option value="4:3">4:3</option>
              <option value="16:9">16:9</option>
              <option value="9:16">9:16</option>
            </select>
          </div>
        </div>

        <label>Format</label>
        <select id="format" style="padding:8px;border-radius:8px">
          <option value="image/jpeg">JPG</option>
          <option value="image/png">PNG</option>
          <option value="image/webp">WEBP</option>
        </select>

        <label>Quality (for JPG/WEBP)</label>
        <input id="quality" type="range" min="10" max="100" value="88" />
        <div class="small" id="qualityVal">Quality: 88%</div>

        <label>Rotate / Flip (applied before export)</label>
        <div style="display:flex;gap:8px">
          <button class="btn secondary" id="rotLeft">⟲ Rotate Left</button>
          <button class="btn secondary" id="rotRight">⟳ Rotate Right</button>
          <button class="btn secondary" id="flipH">⇋ Flip H</button>
          <button class="btn secondary" id="flipV">⇅ Flip V</button>
        </div>

        <div style="display:flex;gap:8px;margin-top:10px">
          <button class="btn" id="processBtn">Process All Images</button>
          <button class="btn secondary" id="downloadAll">Download All</button>
        </div>

        <div style="margin-top:10px">
          <label class="small">Progress</label>
          <progress id="progress" value="0" max="100" style="width:100%"></progress>
          <div class="small" id="progressText">0 / 0</div>
        </div>
      </div>
    </aside>

    <section class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3 style="margin:0">Uploaded Images</h3>
        <div class="small">Processed images: <span id="processedCount">0</span></div>
      </div>
      <div style="height:12px"></div>

      <div id="thumbs" class="thumbs"></div>

      <div style="margin-top:12px">
        <div class="pill">Privacy: All images processed locally in your browser — never uploaded.</div>
      </div>
    </section>
  </main>

  <footer class="info">
    <div>© multiimagex.online · Fast client-side image resizer • No account required • Works offline</div>
  </footer>

<script>
/* ====== Simple Single-file Image Resizer (uses canvas) ======
   Features implemented:
   - Multiple upload (drag & drop + file input)
   - Preview thumbnails
   - Resize by width/height/percent/custom
   - Maintain aspect ratio toggle + presets
   - Format conversion (jpeg/png/webp)
   - Quality slider for jpeg/webp
   - Rotate/flip (applied globally before exporting)
   - Bulk process all images, with progress
   - Download individual images
   - Download All -> sequential downloads (ZIP omitted here; can add JSZip later)
   - LocalStorage for settings
   - All client-side, no external libs
*/
(() => {
  // Elements
  const fileInput = document.getElementById('fileInput');
  const selectBtn = document.getElementById('selectBtn');
  const uploader = document.getElementById('uploader');
  const thumbs = document.getElementById('thumbs');
  const mode = document.getElementById('mode');
  const widthInp = document.getElementById('widthInp');
  const heightInp = document.getElementById('heightInp');
  const keepRatio = document.getElementById('keepRatio');
  const ratioPreset = document.getElementById('ratioPreset');
  const formatSel = document.getElementById('format');
  const quality = document.getElementById('quality');
  const qualityVal = document.getElementById('qualityVal');
  const processBtn = document.getElementById('processBtn');
  const progress = document.getElementById('progress');
  const progressText = document.getElementById('progressText');
  const processedCount = document.getElementById('processedCount');
  const downloadAllBtn = document.getElementById('downloadAll');
  const rotLeft = document.getElementById('rotLeft');
  const rotRight = document.getElementById('rotRight');
  const flipH = document.getElementById('flipH');
  const flipV = document.getElementById('flipV');

  // State
  let files = []; // {file, img, rotated, flipH, flipV, processedBlob, outputName}
  let globalRotate = 0; // deg multiples of 90
  let globalFlipH = false;
  let globalFlipV = false;

  // Load settings from localStorage
  const LS = {
    get(k, def){ try { return JSON.parse(localStorage.getItem(k)) ?? def } catch(e){return def} },
    set(k,v){ localStorage.setItem(k, JSON.stringify(v)); }
  };
  const saved = LS.get('multiimagex.settings', {});
  if(saved.width) widthInp.value = saved.width;
  if(saved.height) heightInp.value = saved.height;
  if(saved.quality) quality.value = saved.quality;
  if(saved.format) formatSel.value = saved.format;
  qualityVal.textContent = `Quality: ${quality.value}%`;

  // Helpers
  function humanBytes(n){
    if(n<1024) return n+' B';
    if(n<1024*1024) return (n/1024).toFixed(1)+' KB';
    return (n/1024/1024).toFixed(2)+' MB';
  }

  function mkThumbItem(fileObj){
    const el = document.createElement('div');
    el.className = 'thumb';

    const img = document.createElement('img');
    img.alt = fileObj.file.name;

    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.innerHTML = `${fileObj.file.name}<br>${humanBytes(fileObj.file.size)} • ${fileObj.file.type || 'image'}`;

    const actions = document.createElement('div');
    actions.className = 'actions';

    const previewBtn = document.createElement('button');
    previewBtn.className = 'btn secondary';
    previewBtn.textContent = 'Preview';
    previewBtn.onclick = () => {
      window.open(URL.createObjectURL(fileObj.file), '_blank');
    };

    const processBtnLocal = document.createElement('button');
    processBtnLocal.className = 'btn';
    processBtnLocal.textContent = 'Process';
    processBtnLocal.onclick = async () => {
      await processSingle(fileObj, updateUIForFile);
    };

    const downloadBtn = document.createElement('button');
    downloadBtn.className = 'btn secondary';
    downloadBtn.textContent = 'Download';
    downloadBtn.onclick = () => {
      if(fileObj.processedBlob){
        downloadBlob(fileObj.processedBlob, fileObj.outputName);
      } else {
        alert('Please process this image first (or click Process All).');
      }
    };

    const removeBtn = document.createElement('button');
    removeBtn.className = 'btn secondary';
    removeBtn.textContent = 'Remove';
    removeBtn.onclick = () => {
      files = files.filter(f=>f!==fileObj);
      el.remove();
      updateCounts();
    };

    actions.appendChild(previewBtn);
    actions.appendChild(processBtnLocal);
    actions.appendChild(downloadBtn);
    actions.appendChild(removeBtn);

    el.appendChild(img);
    el.appendChild(meta);
    el.appendChild(actions);

    // load image preview
    const reader = new FileReader();
    reader.onload = e => {
      img.src = e.target.result;
      // save a small Image element for later processing
      const tmp = new Image();
      tmp.onload = () => {
        fileObj.img = tmp;
      };
      tmp.src = e.target.result;
    };
    reader.readAsDataURL(fileObj.file);

    thumbs.appendChild(el);
  }

  function updateCounts(){
    processedCount.textContent = files.filter(f=>f.processedBlob).length + ' / ' + files.length;
    progressText.textContent = `${files.filter(f=>f.processedBlob).length} / ${files.length}`;
  }

  function downloadBlob(blob, name){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = name;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  }

  // Drag & drop
  ['dragenter','dragover'].forEach(ev=>{
    uploader.addEventListener(ev, e=>{
      e.preventDefault(); e.stopPropagation();
      uploader.classList.add('dragover');
    });
  });
  ['dragleave','drop'].forEach(ev=>{
    uploader.addEventListener(ev, e=>{
      e.preventDefault(); e.stopPropagation();
      uploader.classList.remove('dragover');
    });
  });
  uploader.addEventListener('drop', e=>{
    const dt = e.dataTransfer;
    if(dt && dt.files) handleFiles(dt.files);
  });
  selectBtn.addEventListener('click', ()=>fileInput.click());
  fileInput.addEventListener('change', e=>handleFiles(e.target.files));

  function handleFiles(fileList){
    const list = Array.from(fileList);
    for(const f of list){
      if(!f.type.startsWith('image')) continue;
      const obj = { file: f, img: null, processedBlob: null, outputName: null, rotate:0, flipH:false, flipV:false };
      files.push(obj);
      mkThumbItem(obj);
    }
    updateCounts();
  }

  // Mode management and presets
  mode.addEventListener('change', ()=>{
    // show/hide inputs accordingly (we keep both inputs visible for flexibility)
    LS.set('multiimagex.settings', { width: widthInp.value||'', height: heightInp.value||'', quality: quality.value, format: formatSel.value });
  });

  ratioPreset.addEventListener('change', ()=>{
    const v = ratioPreset.value;
    if(!v) return;
    const [w,h] = v.split(':').map(Number);
    if(w && h){
      // if width filled -> set height to maintain ratio, or vice versa
      const cw = parseInt(widthInp.value||0,10), ch = parseInt(heightInp.value||0,10);
      if(cw) heightInp.value = Math.round(cw * (h/w));
      else if(ch) widthInp.value = Math.round(ch * (w/h));
      else { widthInp.placeholder = `${w*500}px`; heightInp.placeholder = `${h*500}px`; }
    }
  });

  // Quality label
  quality.addEventListener('input', ()=>{ qualityVal.textContent = 'Quality: ' + quality.value + '%'; LS.set('multiimagex.settings', { width: widthInp.value||'', height: heightInp.value||'', quality: quality.value, format: formatSel.value }); });

  // Rotate / flip global (affects exported result)
  rotLeft.addEventListener('click', ()=>{ globalRotate = (globalRotate - 90) % 360; if(globalRotate<0) globalRotate+=360; alert('Global rotation set to '+globalRotate+'° (applied before export)'); });
  rotRight.addEventListener('click', ()=>{ globalRotate = (globalRotate + 90) % 360; alert('Global rotation set to '+globalRotate+'° (applied before export)'); });
  flipH.addEventListener('click', ()=>{ globalFlipH = !globalFlipH; alert('Global horizontal flip: '+(globalFlipH?'ON':'OFF')); });
  flipV.addEventListener('click', ()=>{ globalFlipV = !globalFlipV; alert('Global vertical flip: '+(globalFlipV?'ON':'OFF')); });

  // Core processing logic
  async function processSingle(fileObj, uiCallback){
    if(!fileObj.img) {
      alert('Image not loaded yet.');
      return;
    }
    // determine target size
    const originalW = fileObj.img.naturalWidth || fileObj.img.width;
    const originalH = fileObj.img.naturalHeight || fileObj.img.height;
    let targetW = originalW, targetH = originalH;

    const modeVal = mode.value;
    if(modeVal === 'width'){
      const w = parseInt(widthInp.value,10);
      if(w>0){
        targetW = w;
        if(keepRatio.checked) targetH = Math.round(w * (originalH/originalW));
      }
    } else if(modeVal === 'height'){
      const h = parseInt(heightInp.value,10);
      if(h>0){
        targetH = h;
        if(keepRatio.checked) targetW = Math.round(h * (originalW/originalH));
      }
    } else if(modeVal === 'percent'){
      // treat width input as percent or fallback to both
      let p = parseFloat(widthInp.value || heightInp.value || 100);
      if(isNaN(p) || p<=0) p = 100;
      targetW = Math.max(1, Math.round(originalW * (p/100)));
      targetH = Math.max(1, Math.round(originalH * (p/100)));
    } else if(modeVal === 'custom'){
      const w = parseInt(widthInp.value,10);
      const h = parseInt(heightInp.value,10);
      if(w>0) targetW = w;
      if(h>0) targetH = h;
      if(keepRatio.checked && (w>0 && !h)){
        targetH = Math.round(targetW * (originalH/originalW));
      } else if(keepRatio.checked && (h>0 && !w)){
        targetW = Math.round(targetH * (originalW/originalH));
      }
    }

    // clamp to positive ints
    targetW = Math.max(1, Math.round(targetW));
    targetH = Math.max(1, Math.round(targetH));

    // Create canvas and draw
    const canvas = document.createElement('canvas');
    // handle rotation: swap dims if 90/270
    const rot = globalRotate % 360;
    const swap = rot===90 || rot===270;
    canvas.width = swap ? targetH : targetW;
    canvas.height = swap ? targetW : targetH;
    const ctx = canvas.getContext('2d');

    // optional: background white for jpeg
    if(formatSel.value === 'image/jpeg') {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0,0,canvas.width,canvas.height);
    } else {
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }

    // apply transforms
    ctx.save();
    // move to center for rotation/flip
    ctx.translate(canvas.width/2, canvas.height/2);
    if(globalRotate) ctx.rotate(globalRotate * Math.PI/180);
    const scaleX = globalFlipH ? -1 : 1;
    const scaleY = globalFlipV ? -1 : 1;
    ctx.scale(scaleX, scaleY);

    // compute draw size to fill targetW x targetH canvas after rotation/flip
    // drawImage centered
    const drawW = targetW;
    const drawH = targetH;
    ctx.drawImage(fileObj.img, -drawW/2, -drawH/2, drawW, drawH);
    ctx.restore();

    // toBlob with selected format & quality
    const mime = formatSel.value || 'image/jpeg';
    const q = (mime === 'image/png') ? 0.92 : Math.max(0.01, Math.min(1, (parseInt(quality.value,10)||88)/100));
    const blob = await new Promise(resolve => {
      // for PNG, toBlob ignores quality param in many browsers
      canvas.toBlob(resolve, mime, q);
    });

    // output name
    const base = fileObj.file.name.replace(/\.[^/.]+$/,'');
    const ext = mime === 'image/png' ? 'png' : (mime === 'image/webp' ? 'webp' : 'jpg');
    const outName = `${base}_resized.${ext}`;

    fileObj.processedBlob = blob;
    fileObj.outputName = outName;

    // update UI (size estimate)
    uiCallback && uiCallback(fileObj, canvas);
    updateCounts();
    return fileObj;
  }

  function updateUIForFile(fileObj, canvas){
    // find corresponding thumb img to show updated size
    // We'll show a small badge with output size
    // For simplicity, refresh the whole thumbs area meta text
    const imgs = thumbs.querySelectorAll('.thumb');
    imgs.forEach(node=>{
      const name = node.querySelector('.meta').innerHTML;
      // not a robust mapping; we prefer to just update processedCount which is main indicator
    });
  }

  async function processAll(){
    if(files.length===0){ alert('Please upload images first.'); return; }
    processBtn.disabled = true;
    let done = 0;
    progress.max = files.length; progress.value = 0;
    progressText.textContent = `0 / ${files.length}`;
    for(const f of files){
      try{
        await processSingle(f, updateUIForFile);
      }catch(err){
        console.error('Error processing', f.file.name, err);
      }
      done++;
      progress.value = done;
      progressText.textContent = `${done} / ${files.length}`;
    }
    alert('All images processed. You can download individually or click Download All.');
    processBtn.disabled = false;
  }

  processBtn.addEventListener('click', ()=>{ LS.set('multiimagex.settings', { width: widthInp.value||'', height: heightInp.value||'', quality: quality.value, format: formatSel.value }); processAll(); });

  // Download All - sequential downloads of processed blobs
  downloadAllBtn.addEventListener('click', async ()=>{
    const processed = files.filter(f=>f.processedBlob);
    if(processed.length === 0){
      const ok = confirm('No images have been processed yet. Do you want to process all now?');
      if(ok) { await processAll(); }
    }
    const list = files.filter(f=>f.processedBlob);
    if(list.length===0){ alert('No processed images to download.'); return; }
    // Download sequentially to avoid popup blocking
    for(const f of list){
      downloadBlob(f.processedBlob, f.outputName);
      // small delay to avoid browser throttling
      await new Promise(r=>setTimeout(r, 200));
    }
    alert('Downloads started for all processed images. For ZIP download support request JSZip integration.');
  });

  // Update processed count occasionally
  setInterval(updateCounts, 800);

  // Expose for debugging in console if needed
  window.multiimagex = { files, processAll };
})();
</script>
</body>
</html>
